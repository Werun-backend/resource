# NoSQL	

NoSQL(Not only SQL)是对不同于传统的关系数据库的数据库管理系统的统称，即广义地来说可以把所有不是关系型数据库的数据库统称为NoSQL。

### 面向文档的数据库

例子：MongoDB

优势：处理异构数据，进行面向对象的敏捷开发。

它们的优势是它们不需要一致的数据结构。如果你的数据库布局不断变化，或者你处理的数据集虽然是一个整体但看起来还是很不一样，这些数据库就很有用。当你有许多表都包含有两列叫做“key”和“value”，那就值得考虑使用这种数据库。

### 图数据库

例子：Neo4j,GiraffeDB

优势：数据挖掘

虽然大部分的NoSQL数据库放弃管理数据关系，但这些数据库有时比所谓的关系型数据库更关心数据关系。

它们所关注的是使用数据与其他数据的关系来定义数据。

### 键-值

例子：Redis

优势：根据键快速查找值

它们虽然简单，但胜在快与简单。不需要存储过程，约束，粗发起以及所有其他高级特性。

## ......







## 面向文档的数据库 MongoDB

1. **数据量大**
2. **写入操作频繁**
3. **价值较低的数据, 对事务性要求不高**
4. 新应用, 需求会变, 数据模型无法确定, 想快速迭代开发
5. 应用发展迅速, 需要能快速水平扩展
6. 应用要求存储的数据不丢失
7. 应用需要大量的地理位置查询, 文本查询

对于这样的数据, 更适合用 MongoDB 来实现数据存储



结构

mysql中

数据库--》表--》行

mongdb

数据库--》集合--》文档

文档是文档型数据库的最小单位, 通常情况, 我们存储和操作的内容都是文档



### 数据库 (databases) 管理语法

| 操作                                            | 语法                             |
| ----------------------------------------------- | -------------------------------- |
| 查看所有数据库                                  | `show dbs;` 或 `show databases;` |
| 查看当前数据库                                  | `db;`                            |
| 切换到某数据库 (**若数据库不存在则创建数据库**) | `use <db_name>;`                 |
| 删除当前数据库                                  | `db.dropDatabase();`             |

### 集合 (collection) 管理语法

| 操作         | 语法                                        |
| ------------ | ------------------------------------------- |
| 查看所有集合 | `show collections;`                         |
| 创建集合     | `db.createCollection("<collection_name>");` |
| 删除集合     | `db.<collection_name>.drop()`               |

### 文档操作

- 使用 `db.<collection_name>.insertOne()` 向集合中添加*一个文档*, 参数一个 json 格式的文档
- 使用 `db.<collection_name>.insertMany()` 向集合中添加*多个文档*, 参数为 json 文档数组

```
db.collection.insertOne(  

 { item: "canvas", 

qty: 100, 

tags: ["cotton"], 

size: { h: 28, w: 35.5, uom: "cm" }

 } )
```

- 使用 `db.<collection_name>.find()` 方法对集合进行查询, 接受一个 json 格式的查询条件. 返回的是一个**数组**
- `db.<collection_name>.findOne()` 查询集合中符合条件的第一个文档, 返回的是一个**对象**

......

原生语句可以支持：

#### 正则表达式

```
$ db.collection.find({field:/正则表达式/})

$ db.collection.find({字段:/正则表达式/})
```

#### 比较查询

`<`, `<=`, `>`, `>=` 这些操作符也是很常用的, 格式如下:

```
db.collection.find({ "field" : { $gt: value }}) // 大于: field > value
db.collection.find({ "field" : { $lt: value }}) // 小于: field < value
db.collection.find({ "field" : { $gte: value }}) // 大于等于: field >= value
db.collection.find({ "field" : { $lte: value }}) // 小于等于: field <= value
db.collection.find({ "field" : { $ne: value }}) // 不等于: field != value
```

#### 包含查询

包含使用 `$in` 操作符. 示例：查询评论的集合中 `userid` 字段包含 `1003` 或 `1004`的文档

```
db.comment.find({userid:{$in:["1003","1004"]}})
```

不包含使用 `$nin` 操作符. 示例：查询评论集合中 `userid` 字段不包含 `1003` 和 `1004` 的文档

```
db.comment.find({userid:{$nin:["1003","1004"]}})
```

#### MongoDB的分布式集群架构

MongoDB 有三种集群部署模式，分别为主从复制（Master-Slaver）（已经不推荐使用）、副本集（Replica Set）和分片（Sharding）模式。

 副本集：

在同一台或不同机器上，复制该数据库，并保持数据同步。

MongoDB 中的副本集（Replica Set）是一组维护相同数据集的 mongod 服务。

三个角色：

主要成员：（主节点）主要接收所有写操作。

副本成员：通过复制操作以维护相同的数据集，即备份数据，**不可写操作**，但可以读操作（但需要配置）。

仲裁者：**不保留任何数据的副本，只具有投票选举作用**。当然也可以将仲裁服务器维护为副本集的一部分，即副本成员同时也可以是仲裁者。也是一种从节点类型。

（仲裁者的目的是通过响应其他副本集成员的心跳和选举请求来维护副本集中的仲裁)

特点：

没有固定的主节点，主节点挂了之后，由其他成员投票，获得（计入已挂节点）总节点数的一半以上票数会成为新的主节点。旧主节点修复后会退位为副本成员。



副本集一般是在同一个机器上的，而不能1.防止机器挂掉，也为了2.查找效率，跨多台机器分布数据



分片的概念

三个组件

路由、配置中心、分片

### 分片策略(规则)

##### 知道数据在哪个分片上，直接去那个机器

片键：用于每个文档中都存在的用来划分分片的索引字段

#### 哈希策略

对于 **基于哈希** 的分片 , MongoDB计算一个字段的哈希值, 并用这个哈希值来创建数据块.

在使用基于哈希分片的系统中, 拥有”相近”片键的文档**很可能不会**存储在同一个数据块中, 因此**数据的分离性**更好一些.

#### 范围策略

对于 **基于范围** 的分片 , MongoDB 按照片键的范围把数据分成不同部分. 假设有一个数字的片键 : 想象一个从负无穷到正无穷的直线,每一个片键的值都在直线上画了一个点. MongoDB把这条直线划分为更短的不重叠的片段, 并称之为数据块 ,每个数据块包含了片键在一定范围内的数据.

在使用片键做范围划分的系统中, 拥有”相近”片键的文档**很可能存储在同一个数据块**中, 因此也会存储在同一个分片中.



## Elasticsearch

Elasticsearch 是一个**实时**的**分布式存储、搜索、分析**的引擎。

一般可以说Elasticsearch是**数据搜索与分析引擎**

结构：

关系型数据库：数据库->表->行->列

ElasticSearch:  索引(->类型->)文档->字段

mongoDB:      数据库->集合->文档->字段

Elasticsearch 使用 Json 格式来承载数据模型，已经成为事实上的文档型数据库，虽然底层存储不是 Json 格式，同类型产品有 MongoDB。

ES里真正用于分隔数据的结构只有index索引，没有type类型。类型实际上作为了一个元数据来实现逻辑划分，相当于一条记录里的一个字段来表示其类型。

索引用来划分大类，类型用来划分小类，但类型没有真实地用于分隔数据。

分片和副本：

分片：

Elasticsearch提供了将你的索引细分为多个碎片（或者叫分片）的能力。在创建索引时，可以简单地定义所需的分片数量。每个分片本身就是一个功能完全独立的“索引”，可以驻留在集群中的任何节点上。一个分片默认最大文档数量是20亿。

与mongoDB创建方式上不同。

副本

复制一份当前的分片，副本分片和mongoDB一样只读。总是只可读。

副本从来不会被分配到与它复制的原始分片相同节点上。也就是说，副本是放到另外的节点上的。可以增加副本数量提升查询性能。在主不可用时，副本分片可变为主分片。最新的副本分片提高到主分片的地位。

目的不同配置方式不同，MongoDB也可以将副本配置到其他节点，也可以配置从副本上读，但默认只从主成员读。缺点：

两个连续的es查询请求拿到的结果有可能不一样吗？
答案是可能，因为主分片的数据和副本分片的数据不一定是完全一致的，类似数据库的主从一样，从库不一定和主库的数据是完全一致的。

在默认情况下，Elasticsearch中的每个索引都分配了5个主分片和1个副本，这意味着如果集群中至少有两个节点，那么索引将有5个主分片和另外5个副本分片（PS：这5个副本分片组成1个完整副本），每个索引总共有10个分片。

这里es的master节点实现了主副本选举的逻辑：

节点角色



核心算法：

倒排索引法

例子：百度搜素。

![img](https://pic2.zhimg.com/v2-7707e470e7a39afa5d743e783f1e13ad_r.jpg)

如果没有倒排索引（Inverted Index），想要去找其中的`choice`，需要遍历整个文档，才能找到对应的文档的id，这样做效率是十分低的，所以为了提高效率，我们就给输入的所有数据的都建立索引，并且把这样的索引和对应的文档建立一个关联关系，相当于一个词典。当我们在寻找`choice`的时候就可以直接像查字典一样，直接找到所有包含这个数据的文档的id，然后找到数据。



免费图形化工具推荐：elasticview

[带你走进神一样的Elasticsearch索引机制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/137574234#:~:text=Elasticsearch是一个基于,Lucene 库的开源搜索引擎，它提供分布式的实时文件存储和搜索，可扩展性好，并且支持通过HTTP网络接口交互，数据以JSON格式展示。)

[Elasticsearch 既是搜索引擎又是数据库？真的有那么全能吗？-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/770889)

https://blog.csdn.net/qq_34202873/article/details/122040847 mongoDB的数据格式BSON
