# Wire

# 控制反转与依赖注入

控制反转（Inversion of Control，缩写为IOC），是**面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度**。其中最常见的方式叫做**依赖注入**。依赖注入是生成灵活和松散耦合代码的标准技术，能明确地向组件提供它们所需要的所有依赖关系。在 Go 中通常采用**将依赖项作为参数传递给构造函数**的形式。

好的，用人话来说就是IOC的主要作用是降低代码的耦合性，将像获取依赖之类的职责反转给外部容器，每个对象只需要负责自身的业务逻辑，不需要关注外界，比如在MySQLDao 这个包就只管进行与mysql数据库的交互，至于他所需要的一个*gorm.DB，它不需要管怎么生成这个，只需要创建一个构造函数接收这个参数(依赖项)，而生成这个DB的功能可以在Mysql初始化包里面做。

构造函数`NewStudentMysqlDao`在创建`*gorm.DB`时需要从外部将依赖项`db`作为参数传入，我们在`NewStudentMysqlDao`中无需关注`db`的创建逻辑，实现了代码解耦，也便于代码的维护和扩展。

```go
// StudentMysqlDao 定义MysqlDao层结构体实例
type StudentMysqlDao struct {
	DB *gorm.DB
}

// NewStudentMysqlDao 初始化mysql层结构体实例
func NewStudentMysqlDao(db *gorm.DB) *StudentMysqlDao {
	return &StudentMysqlDao{
		DB: db,
	}
}

// 数据库初始化包
// InitDB 初始化数据库连接 
func InitDB(cfg config.MySQLConfig) (*gorm.DB, error) {
	var err error
	DB, err = gorm.Open(mysql.Open(cfg.DSN), &gorm.Config{})
	if err != nil {
		return nil, err
	}
	return DB, nil
}
```

# 为什么需要依赖注入工具

wire是一种**自动生成依赖注入**的工具，以controller、service、repository三层架构为例，如果在controller层中想用service层的方法，就要进行依赖注入，Java通过@Autowired注解可以很方便的实现依赖注入，go语言则是通过结构体中封装其他包的实例实现调用对应的方法，然后在main函数里面初始化各层。

- 三层架构与IOC的关系
    
    三层架构的核心思想是将应用程序按照功能进行分层，使各层之间职责清晰、相互独立，**便于开发、维护和扩展**，在后端一般分为控制层、业务逻辑层、数据层。这种分层设计在 IOC 理念出现之前就已经存在，但IOC理念可以很好地融入三层架构这种框架，因为在三层架构中，层与层之间通常存在依赖关系。通过 IOC 中的依赖注入方式，可以将这种依赖关系从代码中解耦出来。
    

下面这个示例就是三层架构框架下的main函数现状

在小型应用程序中，我们可以自行创建依赖并手动注入。但是在一个大型应用程序中，手动去实现所有依赖的创建和注入就会比较繁琐。

如果构造函数设置的过多，main函数会过于冗长，而手动注入也难以维护。

你的main函数可能会变成这样：

```go
func main() {
	// 初始化数据库和缓存
	cfg := config.GetConfig()

	if err := database.InitDB(cfg.MySQLConfig); err != nil {
		log.Fatalf("节点：%s 初始化数据库失败: %v", cfg.Node.NodeId, err)
	}
	cache.InitRedis(cfg.RedisConfig)

	// 初始化 Dao
	studentCacheDao := dao.NewStudentCacheDao(cache.RedisClient)
	studentMysqlDao := dao.NewStudentMysqlDao(database.DB)
	memoryDBDao := dao.NewMemoryDBDao(cfg.MemoryDB.Capacity, cfg.MemoryDB.EvictRatio)

	// 初始化 Service
	studentCacheService := service.NewStudentCacheService(studentCacheDao)
	studentMysqlService := service.NewStudentMysqlService(studentMysqlDao)
	studentMdbService := service.NewStudentMdbService(memoryDBDao)
	studentService, err := service.NewStudentService(studentMdbService, 
	studentMysqlService, studentCacheService, cfg.Node)
	
	if err != nil {
		log.Fatalf("节点：%s 初始化学生服务层失败：%v", cfg.Node.NodeId, err)
	}

	// 初始化 Controller
	studentController := controller.NewStudentController(studentService)
	}
	
	//初始化路由
	studentRouter := routers.SetUpStudentRouter(studentController)
```

而使用wire之后，你只需要编写wire.go，编写提供者和注入器，通过wire命令就可以一键依赖注入:

```go
//go:build wireinject  这行不能省 这是告诉编译器略过这个文件，毕竟他只是用来生成代码的
// +build wireinject

package main

import (
	...
	"github.com/google/wire"
	...
)

// ProviderSet 定义依赖注入的提供者集合
var ProviderSet = wire.NewSet(
	config.GetConfig,
	database.InitDB,
	cache.InitRedis,
	dao.NewMemoryDBDao,
	dao.NewStudentCacheDao,
	dao.NewStudentMysqlDao,
	service.NewStudentCacheService,
	service.NewStudentMysqlService,
	service.NewStudentMdbService,
	service.NewStudentService,
	controller.NewStudentController,
	routers.SetUpStudentRouter,
)

// App 定义一个结构体来包装应用程序（main函数）的依赖项
type App struct {
	StudentRouter  *gin.Engine
	StudentService *service.StudentService
}

// InitializeApp 初始化应用程序，生成所需的对象
// Inject
func InitializeApp() (App, error) {
	wire.Build(
		ProviderSet,
		wire.FieldsOf(new(config.Config), "MySQL", "Redis", "Node", "MemoryDB"),
		wire.Struct(new(App), "*"),
	)
	return App{}, nil
}
```

wire会帮我们自动生成依赖注入的代码：

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import(...)
// Injectors from wire.go:

// InitializeApp 初始化应用程序，生成所需的对象
func InitializeApp() (App, error) {
	configConfig := config.GetConfig()
	memoryDBConfig := configConfig.MemoryDB
	memoryDBDao := dao.NewMemoryDBDao(memoryDBConfig)
	studentMdbService := service.NewStudentMdbService(memoryDBDao)
	mySQLConfig := configConfig.MySQL
	db, err := database.InitDB(mySQLConfig)
	if err != nil {
		return App{}, err
	}
	studentMysqlDao := dao.NewStudentMysqlDao(db)
	studentMysqlService := service.NewStudentMysqlService(studentMysqlDao)
	redisConfig := configConfig.Redis
	client := cache.InitRedis(redisConfig)
	studentCacheDao := dao.NewStudentCacheDao(client)
	studentCacheService := service.NewStudentCacheService(studentCacheDao)
	node := configConfig.Node
	studentService, err := service.NewStudentService(studentMdbService, studentMysqlService, studentCacheService, node)
	if err != nil {
		return App{}, err
	}
	studentController := controller.NewStudentController(studentService)
	engine := routers.SetUpStudentRouter(studentController)
	app := App{
		StudentRouter:  engine,
		StudentService: studentService,
	}
	return app, nil
}

// wire.go:

// ProviderSet 定义依赖注入的提供者集合
var ProviderSet = wire.NewSet(config.GetConfig, database.InitDB, cache.InitRedis, dao.NewMemoryDBDao, dao.NewStudentCacheDao, dao.NewStudentMysqlDao, service.NewStudentCacheService, service.NewStudentMysqlService, service.NewStudentMdbService, service.NewStudentService, controller.NewStudentController, routers.SetUpStudentRouter)

// App 定义一个结构体来包装应用程序的依赖项
type App struct {
	StudentRouter  *gin.Engine
	StudentService *service.StudentService
}

```

main函数：

```go
func main() {
	// 使用 wire 生成的代码初始化应用程序
	app, err := InitializeApp()
	studentService := app.StudentService
	studentRouter := app.StudentRouter
	if err != nil {
		log.Fatalf("初始化应用程序失败: %v", err)
	}
}
```

# wire依赖注入的大体步骤

1.编写wire.go文件

2.提供者provider集合

3.编写注入器，注入器就是将依赖按顺序注入并生成所需对象的函数，调用wire.build函数即可

4.在根目录执行wire.exe命令 wire会自动帮你生成一个**wire_gen.go**文件，里面是自动生成的代码

# 具体细节

`wire`中有两个核心概念：**提供者**（provider）和**注入器**（injector）。

## Provider

`Wire`中的提供者就是一个可以产生**值**的普通函数。

例如这个初始化Mysql数据库的函数就是一个提供者

```go
// InitDB 初始化数据库连接
func InitDB(cfg config.MySQLConfig) (*gorm.DB, error) {
	var err error
	DB, err = gorm.Open(mysql.Open(cfg.DSN), &gorm.Config{})
	if err != nil {
		return nil, err
	}
	return DB, nil
}
```

提供者函数必须是可导出的（**首字母大写**）以便被其他包导入。

提供者函数可以使用参数指定依赖项（参数），也可以返回错误

提供者函数可以分组为提供者函数集（**provider set**）。使用`wire.NewSet` 函数可以将多个提供者函数添加到一个集合中。如果经常同时使用多个提供者函数，这非常有用。

```go
package demo

import (
    // ...
    "github.com/google/wire"
)

// ...

var ProviderSet = wire.NewSet(NewX, NewY, NewZ)
```

还可以将其他提供者函数集添加到提供者函数集中。

```go
package demo

import (
    // ...
    "example.com/some/other/pkg"
)

// ...

var MegaSet = wire.NewSet(ProviderSet, pkg.OtherSet)
```

总之就是wire.NewSet的参数可以是提供者函数，也可以是提供者函数集

## Injector

应用程序中是用一个注入器来连接提供者，**注入器会按照依赖顺序调用提供者。**

以Mysql三层架构为例，注入器会先调用初始化mysql函数，生成一个db，再调用dao层，把db传进去生成一个dao，再把dao给service。。service给controller，与我们自己手动注入是一样的。

编写注入器实际上就是编写一个函数，想一下参数和返回值，在函数里面调用wire.build方法就行

像这样：

```go
// App 定义一个结构体来包装应用程序的依赖项
type App struct {
	StudentRouter  *gin.Engine
	StudentService *service.StudentService
}

func InitializeApp() (App, error) {
	wire.Build(
		ProviderSet,
		wire.FieldsOf(new(config.Config), "MySQL", "Redis", "Node", "MemoryDB"),
		wire.Struct(new(App), "*"),
	)
	return App{}, nil
}
```

与提供者一样，注入器也可以输入参数（然后将其发送给提供者），并且可以返回错误，这个错误就是在调用提供者时可能产生的错误。

`wire.Build`的参数和`wire.NewSet`一样：都是提供者集合。这些就在该注入器的代码生成期间使用的提供者集。

将上面的提供者和注入器代码保存到`wire.go`中，文件最上面的`//go:build wireinject` 是必须的，它确保`wire.go`不会参与最终的项目编译。

main函数调用示例：

```go
// 使用 wire 生成的代码初始化应用程序
	app, err := InitializeApp()
	studentService := app.StudentService
	studentRouter := app.StudentRouter
	if err != nil {
		log.Fatalf("初始化应用程序失败: %v", err)
	}
```

# wire的常用api

## wire.NewSet()

这个接口的作用是定义依赖注入的提供者集合，如

```go
var ProviderSet = wire.NewSet(config.GetConfig, database.InitDB, cache.InitRedis, dao.NewMemoryDBDao, dao.NewStudentCacheDao, dao.NewStudentMysqlDao, service.NewStudentCacheService, service.NewStudentMysqlService, service.NewStudentMdbService, service.NewStudentService, controller.NewStudentController, routers.SetUpStudentRouter)
```

推荐使用，简化注入器里面的代码

## wire.Build、wire.FieldsOf、wire.Struct

这三个函数都是注入器可能会用到的

```go
// App 定义一个结构体来包装应用程序的依赖项
type App struct {
	StudentRouter  *gin.Engine
	StudentService *service.StudentService
}

func InitializeApp() (App, error) {
	wire.Build(
		ProviderSet,
		wire.FieldsOf(new(config.Config), "MySQL", "Redis", "Node", "MemoryDB"),
		wire.Struct(new(App), "*"),
	)
	return App{}, nil
}
```

`wire.Build`函数不必多说，是实现注入器的函数，（按顺序调用提供者函数，返回main函数需要的）

`wire.FieldsOf`函数是给提供者函数传参数可能会用到的，提供者函数需要什么，我们就传递什么，但可能在设计的时候会出现不一致的情况。

比如上面的配置文件提供者，他提供的是一个总的配置文件结构体，里面包含了Mysql配置结构体、Redis配置结构体等等，但是 `InitMysql` 函数需要的是 `Mysql` 配置结构体 而不是总的，这个函数的作用就是把结构体中的部分字段提供给需要的提供者。

这个在下面的错误用法会有具体解释

`wire.Struct` 函数是把依赖注入完的结果注入到对应的结构体字段

在有多个返回值的时候，需要把返回值封装成结构体，这个在下面会有具体的解释，此函数就是用来封装结构体的，他有两个参数，一个是结构体，一个是字段，`"*"` 就是把结构体的所有字段都注入，你也可以只注入部分字段,如`”StudentRouter”`，也可以在wire.Struct()参数里面传入*，在不想注入的结构体字段后加上 ``wire:"-"``标记字段使wire忽略这些字段。

```go
type App struct {
	StudentRouter  *gin.Engine  `wire:"-"`
	StudentService *service.StudentService
}
```

# 错误用法示例

我在用wire修改作业代码时出现了两个主要错误，一个是注入器返回值的问题，一个是提供者的问题

## 1.返回值问题

如果注入器函数有多个返回值，那应该封装成结构体，wire在依赖注入时希望第二个返回值是func()

错误用法：

```go
func InitializeApp() (studentRouter *gin.Engine, studentService *service.StudentService, err error) {
	wire.Build(
		ProviderSet,
		wire.FieldsOf(new(config.Config), "MySQL", "Redis", "Node", "MemoryDB"),
		//wire.Struct(new(App), "*"),
	)
	return studentRouter, studentService, nil
}
```

这里返回值的第二个值 studentService并非wire认为的函数 就会报错

wire在处理依赖注入时对返回值有特定的逻辑和规则

封装成结构体返回：

```go
// App 定义一个结构体来包装应用程序的依赖项
type App struct {
	StudentRouter  *gin.Engine
	StudentService *service.StudentService
}

// InitializeApp 初始化应用程序，生成所需的对象
func InitializeApp() (App, error) {
	wire.Build(
		ProviderSet,
		wire.FieldsOf(new(config.Config), "MySQL", "Redis", "Node", "MemoryDB"),
		wire.Struct(new(App), "*"),
	)
	return App{}, nil
}
```

这里看似还是返回了2个值，一个结构体，一个error，但是wire在构建时把error当成生成结构体过程中产生的错误，也就是把这两个认为是一体的，

即`wire` 把 `App` 结构体看作一个单一的、可处理的依赖对象，然后按照它的规则去构建这个对象，`error` 只是构建过程中的一个状态反馈，不影响 `wire` 对主要依赖项（`App` 结构体）的处理，所以依赖注入能够成功。

## 2.提供者函数问题

```go
//go:build wireinject
// +build wireinject

package main

import (
....
)

// ProviderSet 定义依赖注入的提供者集合
var ProviderSet = wire.NewSet(
	config.GetConfig,
	database.InitDB,
	cache.InitRedis,
	dao.NewMemoryDBDao,
	dao.NewStudentCacheDao,
	dao.NewStudentMysqlDao,
	service.NewStudentCacheService,
	service.NewStudentMysqlService,
	service.NewStudentMdbService,
	service.NewStudentService,
	controller.NewStudentController,
	routers.SetUpStudentRouter,
)

// App 定义一个结构体来包装应用程序的依赖项
type App struct {
	StudentRouter  *gin.Engine
	StudentService *service.StudentService
}

// InitializeApp 初始化应用程序，生成所需的对象
func InitializeApp() (App, error) {
	wire.Build(
		ProviderSet,
		wire.FieldsOf(new(config.Config), "MySQL", "Redis", "Node", "MemoryDB"),
		wire.Struct(new(App), "*"),
	)
	return App{}, nil
}
```

重点就是函数需要什么，你就给他什么，但是这个过程中会产生一些问题

以注入内存数据库数据层为例

```go
func NewMemoryDBDao(capacity int,evictRatio float64) *MemoryDBDao {
	mdb := &MemoryDBDao{
		dataMap:    make(map[string]interface{}),
		expires:    make(map[string]time.Time),
		capacity:   capacity,
		lruList:    list.New(),
		lruMap:     make(map[string]*list.Element),
		evictRatio: evictRatio,
	}
	return mdb
}

func NewMemoryDBDao(cfg config.MemoryDBConfig) *MemoryDBDao {
	mdb := &MemoryDBDao{
		dataMap:    make(map[string]interface{}),
		expires:    make(map[string]time.Time),
		capacity:   cfg.Capacity,
		lruList:    list.New(),
		lruMap:     make(map[string]*list.Element),
		evictRatio: cfg.EvictRatio,
	}
	return mdb
}

//这是配置里的内存数据库
// MemoryDBConfig 定义内存数据库配置结构体
type MemoryDBConfig struct {
	Capacity   int     //内存容量
	EvictRatio float64 //触发内存淘汰时淘汰的键的比例
}
```

在函数的参数中，一种是直接提供具体字段，一种是把配置结构体传过去

如果要传字段，首先你的提供者集合里面并没有提供这个字段，提供的是总的配置结构体，你需要再创建新的函数，并把他添加到提供者集合里 来返回字段，但是如果是传封装的**结构体**，那就只需要调用`wire.FieldsOf(new(config.Config), "MySQL", "Redis", "Node", "MemoryDB"),` 方法，把总的结构体配置中的MemoryDB配置字段找出来传入即可，前面的Redis、Mysql、Node也是同理

这样不仅方便依赖注入，还使结构更加清晰紧凑了

# 总结

在第一次使用wire修改代码时爆了一堆问题，我总结为上面两个主要的部分，一度让我感觉有这个时间我能手动注入几百个函数了，但是熟悉使用后还是很方便的，还会帮助你养成代码规范的习惯，例如在设计配置文件里的结构体，在设计提供者函数需要的参数时…

wire有以下3个主要的优点

- **依赖管理清晰**：在**大型项目**中，（划重点大型项目，当有几百个依赖注入以及团队合作开发时你会想念wire的）依赖关系可能非常复杂，涉及多个组件和层次的依赖。Wire 通过明确的提供者函数和注入规则，将依赖关系清晰地表示出来，使得代码的结构更加清晰，易于理解和维护。
- **团队协作**：在团队开发中，Wire 使得依赖关系的管理更加规范化。开发人员可以清楚地看到每个组件的依赖情况，便于理解整个系统的架构，也有利于新成员快速上手项目，提高团队协作的效率。
- **代码生成**：Wire 通过代码生成的方式来实现依赖注入，这可以避免在运行时进行反射等操作，提高了应用程序的性能。同时，生成的代码是静态类型安全的，减少了因动态类型检查导致的潜在错误。
    
    除了wire，还有一些依赖注入工具是通过反射实现的，例如Uber的 dig 和Facebook的 inject ，反射的缺点也就是性能低一些，只有运行了才报错
    

最主要的优点我认为是依赖管理清晰和便于团队协作

总之，我还是推荐大家学一下wire的~

因为时间有限，讲的并不是很详细，大家可以自行查阅，也欢迎大家后面和我讨论

博客：

[依赖注入工具-wire | 李文周的博客](https://www.liwenzhou.com/posts/Go/wire/#c-0-3-0)

官方文档：

[wire/docs/guide.md at main · google/wire](https://github.com/google/wire/blob/main/docs/guide.md)