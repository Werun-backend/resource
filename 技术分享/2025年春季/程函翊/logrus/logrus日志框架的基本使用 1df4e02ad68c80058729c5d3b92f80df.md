# logrus日志框架的基本使用

## logrus的优势：

**1.结构化日志**

支持以键值对形式组织日志数据，输出 JSON 或自定义格式，便于后续分析和过滤。

**2.多级日志级别**

提供Trace、Debug、Info、Warn、Error、Fatal、Panic七个日志级别，可动态调整。

**3.钩子（Hook）机制**

通过钩子可在日志记录的不同阶段插入自定义逻辑，如分级存储、告警触发等。

**4.多格式输出**

支持文本、JSON 等格式，还可自定义格式化器。

**5.多目的地输出**

可同时将日志输出到控制台、文件、远程服务等。

# 1. logrus框架依赖下载

```go
go get github.com/sirupsen/logrus
```

# 2. logrus常用方法

## 2.1.1 常用方法及其输出

```go
package main

import "github.com/sirupsen/logrus"

func main() {
	logrus.Error("出错")
	logrus.Warnln("警告")
	logrus.Infof("信息")
	logrus.Debugf("调试")
	logrus.Println("打印")
}

//控制台输出如下：
time="2025-04-26T14:49:26+08:00" level=error msg="出错"
time="2025-04-26T14:49:26+08:00" level=warning msg="警告"
time="2025-04-26T14:49:26+08:00" level=info msg="信息"
time="2025-04-26T14:49:26+08:00" level=info msg="打印"
```

## 2.1.2 logrus日志等级

<aside>
💡

为什么Debugf的日志信息没有输出呢？

因为logrus默认的日志输出等级是info。

</aside>

```go
fmt.Println(logrus.GetLevel())  //info
```

### 日志等级划分

```go
	//级别从高到低
	//设置级别以上的所有级别的日志都会被输出
	//比如设置了日志级别为DebugLevel，那么从Panic到Debug级别的所有日志都会被输出，但是Trace级别的日志不会被输出
	PanicLevel    //最高级别，通常用于不可恢复的错误，触发后会调用 panic()。
	FatalLevel    //致命错误级别，记录日志后调用 os.Exit(1)，程序退出。
	ErrorLevel    //错误级别，表示可恢复的错误，如文件打开失败、网络请求失败等。
	WarnLevel     //警告级别，表示潜在问题，但不是严重错误，如配置项缺失默认值。
	InfoLevel     //信息级别，常规运行日志，用于记录正常流程中的重要信息。
	DebugLevel    //调试级别，详细信息，通常用于开发环境调试程序行为。
	TraceLevel    //最低级别，比 Debug 更详细，用于追踪代码执行路径或性能分析。       
```

### 更改日志级别

如果你想显示Debug级别的日志，那么你可以更改日志显示等级

```go
package main

import (
	"github.com/sirupsen/logrus"
)

func main() {
	//设置日志级别为Debug
	logrus.SetLevel(logrus.DebugLevel)
	
	logrus.Error("出错")
	logrus.Warnln("警告")
	logrus.Infof("信息")
	logrus.Debugf("调试")
	logrus.Println("打印")
}

//输出如下
time="2025-04-26T16:56:00+08:00" level=error msg="出错"
time="2025-04-26T16:56:00+08:00" level=warning msg="警告"
time="2025-04-26T16:56:00+08:00" level=info msg="信息"
time="2025-04-26T16:56:00+08:00" level=debug msg="调试"
time="2025-04-26T16:56:00+08:00" level=info msg="打印"
```

日志级别一般是和系统环境挂钩，例如开发环境和测试环境，肯定就要显示debug信息。

线上环境就不需要这些日志，可能只显示warning的日志。

## 2.1.3 一些设置

### 设置特定字段

```go
package main

import "github.com/sirupsen/logrus"

func main() {
	log1 := logrus.WithField("project", "study")
	log1.Errorln("hello")
	// time="2025-04-26T18:46:56+08:00" level=error msg=hello project=study
	
	log2 := logrus.WithFields(logrus.Fields{
		"project": "study",
		"user":    "admin",
		"time":    "2020-01-01",
	}) 
	log2.Warning("hello")
	// time="2025-04-26T18:46:56+08:00" level=warning msg=hello fields.time=2020-01-01 project=study user=admin
	
	log3 := log2.WithFields(logrus.Fields{
		"id": 1,
	})
	log3.Warning("hello")
}	//time="2025-04-26T18:46:56+08:00" level=warning msg=hello fields.time=2020-01-01 id=1 project=study user=admin
```

通常，在一个应用中、或者应用的一部分中，都有一些固定的Field。

比如在处理用户http请求时，上下文中，所有的日志都会有 request_id 和  user_id

为了避免每次记录日志都要使用

```go
logrus.WithFields(logrus.Fields{
	"request_id": requesy_id,
	"user_id": user_id
	}
)
```

我们可以创建一个`logrus.Entry`实例，为这个实例设置默认Fields，在上下文中使用这个`logrus.Entry`实例记录日志即可。

```go
package main

import (
	"github.com/sirupsen/logrus"
)

func main() {
	// 创建一个 logrus.Logger 实例
	logger := logrus.New()

	// 设置日志格式为 JSON 格式
	logger.SetFormatter(&logrus.JSONFormatter{})
	
	// 两个参数可以从网络路径中获取
	request_id := "1234567890"
	user_id := "1234567890"
	
	// 创建一个 logrus.Entry 实例
	entry := logger.WithFields(logrus.Fields{
		"request_id" : request_id,
		"user_id" : user_id,
	})
	
	entry.Info("hello")
}    
```

<aside>
💡

在 `logrus` 库中，`WithFields` 方法用于添加额外的字段到日志记录中，这些字段会在日志输出时一同显示。不过，`logrus` 本身并不会保证 `WithFields` 方法中各字段的输出顺序。

- **原因分析**
    
    `logrus` 在处理日志字段时，通常会把这些字段存储在一个 `map` 数据结构里。在 Go 语言中，`map` 是一种无序的键值对集合，这意味着 `map` 中的元素不会按照插入顺序存储，因此在遍历 `map` 时，元素的顺序是不确定的。所以，`WithFields` 方法中各字段的输出顺序也就无法保证。
    
</aside>

### 显示样式 Text 和 JSON

默认的是以 text 的形式展示，也可以设置为 JSON

```go
package main

import "github.com/sirupsen/logrus"

func main() {
	logrus.SetFormatter(&logrus.JSONFormatter{})
	log1 := logrus.WithField("key", "value")
	log1.Errorln("Hello World")
}

//输出如下
{"key":"value","level":"error","msg":"Hello World","time":"2025-04-26T19:18:36+08:00"}
```

### 控制台中自定义颜色

如果我们想要在控制台中显示颜色，一般的做法都是使用 ANSI 控制码，用于设置文本颜色。\033是控制码的开始，\ 033[m是控制码的结束，是八进制数字，[31m表示将文本设置为红色。

ANSI控制码是用于在中断和控制台中控制文本格式和颜色的一种标准。它们通常用于在命令行界面（CLI）程序中输出彩色文本或者在文本模式下的图形界面（GUI）中输出文本。

```go
package main

import "fmt"

func main() {

	//字体色
	fmt.Println("\033[30m 黑色 \033[0m")
	fmt.Println("\033[31m 红色 \033[0m")
	fmt.Println("\033[32m 绿色 \033[0m")
	fmt.Println("\033[33m 黄色 \033[0m")
	fmt.Println("\033[34m 蓝色 \033[0m")
	fmt.Println("\033[35m 紫色 \033[0m")
	fmt.Println("\033[36m 青色 \033[0m")
	fmt.Println("\033[37m 灰色 \033[0m")

	//背景色
	fmt.Println("\033[40m 黑色背景 \033[0m")
	fmt.Println("\033[41m 红色背景 \033[0m")
	fmt.Println("\033[42m 绿色背景 \033[0m")
	fmt.Println("\033[43m 黄色背景 \033[0m")
	fmt.Println("\033[44m 蓝色背景 \033[0m")
	fmt.Println("\033[45m 紫色背景 \033[0m")
	fmt.Println("\033[46m 青色背景 \033[0m")
	fmt.Println("\033[47m 灰色背景 \033[0m")

}
```

![联想截图_20250426195118.png](%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20250426195118.png)

也可以这样写

```go
fmt.Printf("\x1b[0;%dm%s\x1b[0m", 31, "你好")

// \x1b：这是一个转义字符，代表 ESC 键（ASCII 码为 27），它是 ANSI 转义序列的起始标识。
// [0;%dm：0 是默认的显示模式，%d 属于格式化占位符，会被后面的 31 所替代。31 代表红色文字。m 则是转义序列的结束标志。
// %s：同样是格式化占位符，会被 "你好" 替代。
// \x1b[0m：此为重置转义序列，作用是把文本颜色和样式恢复到默认状态。

//输出如下：
你好
```

logrus也是支持颜色输出的

我们需要在配置中去进行开启

```go
logrus.SetFormatter(&logrus.TextFormatter{ForceColors:true})
```

不过，只开启这个参数设置的话，输出会有些奇怪。

```go
package main

import "github.com/sirupsen/logrus"

func main() {
	logrus.SetFormatter(&logrus.TextFormatter{ForceColors: true})
	log1 := logrus.WithField("key", "value")
	log1.Warning("Hello World")
}
```

输出如下：

[0000]表示时间戳，即程序启动到输出日志经过的时间。因为没有显示完整的时间戳。

![联想截图_20250426200547.png](%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20250426200547.png)

还有一些其他的配置

- `SetFomatter`方法相关配置
    
    `ForceColors`：是否强制使用颜色输出
    
    `DisableColors`：是否禁用颜色输出
    
    `ForceQuate`：是否强制引用所有值
    
    `DisableTimestamp`：是否禁用时间戳信息
    
    `FullTimestamp`：是否在连接到TTY是输出完整的时间戳
    
    `TimestampFormat`：用于输出完整时间戳的时间戳格式
    

代码示例：

```go
package main

import "github.com/sirupsen/logrus"

func main() {
  // ForceColors表示是否开启颜色输出
  // TimestampFormat可以自定义时间戳格式
  // FullTimestamp表示是否开启完整时间戳显示
	logrus.SetFormatter(&logrus.TextFormatter{ForceColors: true, TimestampFormat: "2006-01-02 15:04:05", FullTimestamp: true})
	log1 := logrus.WithFields(logrus.Fields{"name": "log1"})
	log1.Info("hello")
}

//输出：INFO[2025-04-26 20:21:16] hello                     name=log1

```

## 2.1.4 输出目标控制

### 输出到日志文件

默认的输出是在控制台上，但是后期想要找到某些日志，翻控制台可就不太好找了。

使用`func SetOutput(out io.Writer)`即可实现输出到日志文件中。在这之前吗，需要我们有一个`Writer`的对象。

```go
package main

import (
    "os"
    "github.com/sirupsen/logrus"
)

func main() {
    
    // 打开文件，使用 os.O_CREATE|os.O_WRONLY|os.O_APPEND 标志
    // os.O_CREATE 标志：如果指定的文件不存在，就创建该文件；若文件已经存在，则不会对其进行任何操作。
    // os.O_WRONLY 标志：以只写模式打开文件。
    // os.O_APPEND 标志：以追加模式打开文件。在这种模式下，每次写入数据时，数据都会被追加到文件的末尾，而不会覆盖原有内容。
    
    file, err := os.OpenFile("info.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        // 若文件打开失败，记录错误信息并退出程序
        logrus.Fatalf("Failed to open log file: %v", err)
    }
    
    // 使用 defer 关键字确保文件在函数结束时关闭
    defer file.Close()

    // 设置 logrus 的输出为打开的文件
    logrus.SetOutput(file)

    // 输出一条测试日志
    logrus.Info("This is a test log message.")
}

//输出结果
在程序的当前工作目录中创建了一个新的文件info.log
在info.log文件中存入了一行日志信息：
time="2025-04-26T20:30:39+08:00" level=info msg="This is a test log message."
```

<aside>
💡

文件和目录权限的表示形式：

### **权限表示规则**

在这些系统中，文件和目录的权限通过三位八进制数来描述，从左到右每一位分别对应不同用户组的权限：

- 第一位代表文件所有者（user）的权限。
- 第二位代表文件所属组（group）的权限。
- 第三位代表其他用户（others）的权限。

而每一位八进制数又由三个二进制位组成，分别对应读（`r`）、写（`w`）、执行（`x`）权限，其对应关系如下：

- 读权限（`r`）：二进制为 `100`，八进制为 `4`。
- 写权限（`w`）：二进制为 `010`，八进制为 `2`。
- 执行权限（`x`）：二进制为 `001`，八进制为 `1`。

### **`0666` 权限解析**

三者都有读写权限，但没有执行权限

</aside>

### 同时输出到屏幕和文件

```go
package main

import (
	"github.com/sirupsen/logrus"
	"io"
	"os"
)

func main() {
	logrus.SetFormatter(&logrus.TextFormatter{})
	logrus.SetOutput(os.Stdout)
	// 设置output，默认为Stderr，可以为任何io.Writer，比如文件*os.File
	file, _ := os.OpenFile("checkemstools.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	writers := []io.Writer{
		file,
		os.Stdout,
	}
	// 同时写文件和屏幕
	fileAndStdoutWriter := io.MultiWriter(writers...)
	logrus.SetOutput(fileAndStdoutWriter)
	log1 := logrus.WithFields(logrus.Fields{"date": "2019-01-01", "user": "admin"})
	log1.Info("this is a logrus info")
}

//输出内容：
在程序的当前工作目录中创建了一个新的文件checkemstools.log
在checkemstools.log文件中存入了一行日志信息：
time="2025-04-26T21:04:01+08:00" level=info msg="this is a logrus info" date=2019-01-01 user=admin
在控制台输出了日志信息：
time="2025-04-26T21:04:01+08:00" level=info msg="this is a logrus info" date=2019-01-01 user=admin
```

### 自定义格式

```go
package main

import (
	"bytes"
	"fmt"
	"github.com/sirupsen/logrus"
	"os"
	"path"
)

// 颜色代码（设置背景色以4开头，设置字体色以3开头）
const (
	ccBlack  = 0
	ccRed    = 1
	ccGreen  = 2
	ccYellow = 3
	ccBlue   = 4
	ccPurple = 5
	ccCyan   = 6
	ccWhite  = 7
)

type MyFormatter struct {
	Prefix     string //前缀字段
	TimeFormat string //时间格式字段
}

func (f MyFormatter) Format(entry *logrus.Entry) ([]byte, error) {

	// 设置颜色
	var color int

	switch entry.Level {
	case logrus.ErrorLevel:
		color = ccRed
	case logrus.WarnLevel:
		color = ccYellow
	case logrus.InfoLevel:
		color = ccGreen
	case logrus.DebugLevel:
		color = ccBlue
	default:
		color = ccWhite
	}

	// 设置 buffer 缓冲区
	var b *bytes.Buffer

	// 判断缓冲区是否为空，如果为空，则开辟一块新内存，不为空则直接赋值
	if entry.Buffer != nil {
		b = entry.Buffer
	} else {
		b = &bytes.Buffer{}
	}

	// 时间格式化
	formatTime := entry.Time.Format(f.TimeFormat)

	// 判断是否设置了调用者信息（是否存在调用日志记录函数的代码位置）
	if entry.HasCaller() {
		// 自定义文件路径
		// 函数名称
		funcVal := entry.Caller.Function
		// 文件路径和行号。  path.Base方法用于显示不重复的路径，简化输出
		fileVal := fmt.Sprintf("%s:%d", path.Base(entry.Caller.File), entry.Caller.Line)
		// 输出格式化
		fmt.Fprintf(b, "[%s] \033[3%dm[%s]\033[0m [%s] %s %s %s\n", f.Prefix, color, entry.Level, formatTime, fileVal, funcVal, entry.Message)
	} else {
		fmt.Fprintf(b, "[%s] \033[3%dm[%s]\033[0m [%s] %s\n", f.Prefix, color, entry.Level, formatTime, entry.Message)
	}
	return b.Bytes(), nil
}

var log *logrus.Logger

// 初始化日志，隐式调用
func init() {
	log = NewLog()
}

func NewLog() *logrus.Logger {
	//新建一个实例
	mLog := logrus.New()                                                               
	//设置输出到标准输出
	mLog.SetOutput(os.Stdout)                                                          
	//开启返回函数名和行号（即开启调用者信息）
	mLog.SetReportCaller(true)                                                        
	//设置日志级别
	mLog.SetLevel(logrus.DebugLevel)                                                   
	//设置格式
	mLog.SetFormatter(&MyFormatter{Prefix: "GORM", TimeFormat: "2006-01-02 15:04:05"}) 

	return mLog
}
func main() {
	log.Debug("debug")
	log.Info("info")
	log.Warn("warn")
	log.Error("error")
}
```

<aside>
💡

`bytes.buffer`缓冲区的作用：

- **1. 性能优化**
    
    日志记录时，频繁的 I/O 操作（如将日志内容写入文件或标准输出）会消耗较多的系统资源，影响程序的性能。缓冲区能将多次小的写入操作合并成一次大的写入操作，减少 I/O 操作的次数，从而提升性能。
    
    在代码里，`bytes.Buffer`会先把日志内容存储起来，直到日志格式化完成，再一次性把缓冲区中的内容输出到标准输出（`os.Stdout`），以此减少与标准输出的交互次数。
    
- **2. 灵活性与可复用性**
    
    
    - **方便格式化操作**：`bytes.Buffer`提供了一系列方法，像`Write`、`WriteString`、`WriteByte`等，便于进行字符串拼接和格式化操作。在代码中，借助`fmt.Fprintf`函数把格式化后的日志内容写入`bytes.Buffer`，这样就能很方便地组合不同的日志信息。
    
    - **避免重复分配内存**：使用`bytes.Buffer`能够避免在每次写入日志时都重新分配内存。因为`bytes.Buffer`可以动态调整其容量，所以在多次写入日志时，可复用已分配的内存空间。
    
</aside>

# 3. Hook

`logrus`最令人心动的功能就是其可扩展的`HOOK`机制了，通过在初始化时为`logrus`添加`hook`，`logrus`可以实现各种扩展功能。

## 3.1 Hook的接口定义形式

```go
// Levels() 方法用于指定该钩子（Hook）会应用于哪些日志级别
// Fire(*Entry) error 方法是钩子的核心逻辑所在
type Hook interface {
	Levels() []logrus.Level
	Fire(*Entry) error
}
```

## 3.2 Hook的接口实现案例

### 3.2.1 写入一个公用字段

例如实现：每条日志都加入一个`field` 公用字段

我们需要实现两个方法以实现`Hook`接口

```go
package main

import (
	"github.com/sirupsen/logrus"
)

type MyHook struct {
}

// 设置logrus日志等级为所有等级都可输出
func (hook MyHook) Levels() []logrus.Level {
	return logrus.AllLevels
}

// 设置一个field
func (hook MyHook) Fire(entry *logrus.Entry) error {
	entry.Data["cc"] = "cc"
	return nil
}

func main() {
	logrus.AddHook(&MyHook{})

	logrus.Warnln("test")
	logrus.Errorf("test")
}

//输出如下
//所有的日志记录中都会有cc=cc这个Hook添加的field
time="2025-04-29T16:41:42+08:00" level=warning msg=test cc=cc
time="2025-04-29T16:41:42+08:00" level=error msg=test cc=cc
```

### 3.2.2 实现多文件写入

`logrus hook`  是一个值得深入学习的设计，你可以轻易使用hook来实现多文件写入。

比如，`error`级别的日志独立输出到`error.log`文件里，其他都放在一起。

```go
package main

import (
	"fmt"
	"github.com/sirupsen/logrus"
	"os"
)

// 传入一个写入器，用于向文件中写入日志信息
type MyHook struct {
	Writer *os.File
}

// 设置logrus的level为ErrorLevel，只有日志级别为Error的日志才能被输出
func (hook MyHook) Levels() []logrus.Level {
	return []logrus.Level{logrus.ErrorLevel}
}

func (hook MyHook) Fire(entry *logrus.Entry) error {
	// 将日志条目转换为字符串
	line, err := entry.String()
	if err != nil {
	  // 如果转换过程中发生错误，将错误信息输出到标准错误流
		fmt.Fprintf(os.Stderr, "Unable to read entry: %v\n", err)
		return err
	}
	// 将转换后的日志条目字符串写入到指定的 Writer 中
	hook.Writer.Write([]byte(line))
	return nil
}

func main() {
	// 设置日志格式
	logrus.SetFormatter(&logrus.TextFormatter{ForceColors: true, TimestampFormat: "2006-01-02 15:04:05", FullTimestamp: true})
	// 开启返回函数名和行号
	logrus.SetReportCaller(true)
	// 创建需要写入的文件
	file, _ := os.OpenFile("err.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	hook := &MyHook{Writer: file}
	logrus.AddHook(hook)
	logrus.Errorf("text")
}

//输出如下
在控制台中：
ERRO[2025-04-29 16:52:38]D:/develop/awesomeProject/main.go:33 main.main() text   
工作目录下自动新建了一个文件err.log，并在其中写入日志（文件中不能使用ANSI颜色码）：
[31mERRO[0m[2025-04-29 16:52:38]D:/develop/awesomeProject/main.go:33 main.main() text
```

# 4. 日志分割

## 4.1 按时间分割

### 4.1.1 一般方法

```go
package main

import (
	"errors"
	"fmt"
	log "github.com/sirupsen/logrus"
	"io"
	"os"
	"path/filepath"
	"time"
)

// LogFormatter 自定义日志格式化器结构体
type LogFormatter struct {
}

// Format 实现 logrus.Formatter 接口的 Format 方法，用于格式化日志条目
func (s *LogFormatter) Format(entry *log.Entry) ([]byte, error) {
	// 获取当前时间并格式化
	timestamp := time.Now().Format("2006-01-02 15:04:05")
	// 定义文件名和行号变量
	var file string
	var len int
	// 检查日志条目是否包含调用者信息
	if entry.Caller != nil {
		// 获取调用者文件的基本名称
		file = filepath.Base(entry.Caller.File)
		// 获取调用者文件的行号
		len = entry.Caller.Line
	}
	// 按照指定格式拼接日志信息
	msg := fmt.Sprintf("[%s] [%s] [%s:%d] %s\n", timestamp, entry.Level, file, len, entry.Message)
	// 将拼接好的日志信息转换为字节切片并返回
	return []byte(msg), nil
}

// logFileWriter 自定义日志文件写入器结构体
type logFileWriter struct {
	file     *os.File  // 打开的日志文件句柄
	logPath  string    // 日志文件存储的根路径
	fileDate string    // 当前日志文件对应的日期
	appName  string    // 应用程序的名称
}

// Write 实现 io.Writer 接口的 Write 方法，用于将日志数据写入文件
func (p *logFileWriter) Write(data []byte) (n int, err error) {
	// 检查 logFileWriter 实例是否为空
	if p == nil {
		return 0, errors.New("logFileWriter is nil")
	}
	// 检查文件句柄是否为空
	if p.file == nil {
		return 0, errors.New("file not opened")
	}

	// 获取当前日期并格式化为 "2006-01-02" 格式
	fileDate := time.Now().Format("2006-01-02")
	// 判断当前日期是否与之前记录的日期不同
	if fileDate != p.fileDate {
		// 若日期不同，关闭当前打开的文件
		p.file.Close()
		// 创建新日期对应的日志目录
		err = os.MkdirAll(fmt.Sprintf("%s/%s", p.logPath, fileDate), os.ModePerm)
		if err != nil {
			return 0, err
		}
		// 生成新日期对应的日志文件名
		filename := fmt.Sprintf("%s/%s/%s-%s.log", p.logPath, fileDate, p.appName, fileDate)

		// 以创建、追加写入模式打开新的日志文件
		p.file, err = os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
		if err != nil {
			return 0, err
		}
		// 更新记录的日期
		p.fileDate = fileDate
	}

	// 将日志数据写入文件，并返回写入的字节数和可能的错误
	n, e := p.file.Write(data)
	return n, e
}

// InitLog 初始化日志配置，包括创建日志文件、设置输出和格式化器等
func InitLog(logPath string, appName string) {
	// 获取当前日期并格式化为 "2006-01-02" 格式
	fileDate := time.Now().Format("2006-01-02")
	// 创建当前日期对应的日志目录，os.ModePerm 的值是 0777
	err := os.MkdirAll(fmt.Sprintf("%s/%s", logPath, fileDate), os.ModePerm)
	if err != nil {
		log.Error(err)
		return
	}

	// 生成当前日期对应的日志文件名
	filename := fmt.Sprintf("%s/%s/%s-%s.log", logPath, fileDate, appName, fileDate)
	file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
	if err != nil {
		log.Error(err)
		return
	}

	// 创建 logFileWriter 实例
	fileWriter := logFileWriter{file, logPath, fileDate, appName}
	// 默认设置日志输出到标准输出
	log.SetOutput(os.Stdout)
	// 定义一个写入器切片，包含文件写入器和标准输出写入器
	writers := []io.Writer{
		&fileWriter,
		os.Stdout,
	}
	// 创建一个多写入器，可同时将日志写入文件和标准输出
	fileAndStdoutWriter := io.MultiWriter(writers...)
	if err == nil {
		log.SetOutput(fileAndStdoutWriter)
	} else {
		log.Info("Fail to log into file, using default stderr")
	}
	log.SetReportCaller(true)
	log.SetFormatter(new(LogFormatter))
}

func main() {
	InitLog("awesomeProject/logs/", "test")
	log.Errorf("test")
	log.Infof("test")
	log.Warnln("test")
	log.Debugf("test")
}

//输出结果如下：

在控制台中输出了日志：
[2025-05-04 10:56:39] [error] [main.go:100] test
[2025-05-04 10:56:39] [info] [main.go:101] test
[2025-05-04 10:56:39] [warning] [main.go:102] test

在项目目录下新建了一个logs文件夹
在logs文件夹下创建了一个文件夹2025-05-04
在该文件夹下创建了一个文件test-2025-05-04.log
文件中存放了三条日志：
[2025-05-04 10:56:39] [error] [main.go:100] test
[2025-05-04 10:56:39] [info] [main.go:101] test
[2025-05-04 10:56:39] [warning] [main.go:102] test
在同一天二次运行程序后，文件中会新增三条日志，不会覆盖原有的日志。
不在同一天运行程序后，会创建一个新的文件并在其中存放当天的日志。
这样就实现了日志按时间分割。
```

### 4.1.2 利用hook实现时间分割

```go
package main

import (
	"fmt"
	"github.com/sirupsen/logrus"
	"os"
	"time"
)

type FileDateHook struct {
	file     *os.File
	logPath  string
	fileDate string
	appName  string
}

func (hook FileDateHook) Levels() []logrus.Level {
	return logrus.AllLevels
}

func (hook FileDateHook) Fire(entry *logrus.Entry) error {
  //按每分钟作为文件分割点
	timer := entry.Time.Format("2006-01-02_15-04")
	line, _ := entry.String()
	if hook.fileDate == timer {
		hook.file.Write([]byte(line))
		return nil
	}
	//时间不等
	hook.file.Close()
	os.MkdirAll(fmt.Sprintf("%s/%s", hook.logPath, timer), os.ModePerm)
	filename := fmt.Sprintf("%s/%s/%s.log", hook.logPath, timer, hook.appName)

	hook.file, _ = os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
	hook.fileDate = timer
	hook.file.Write([]byte(line))
	return nil
}

func InitFile(logPath, appName string) {
	fileDate := time.Now().Format("2006-01-02_15-04")
	// 创建日志目录
	err := os.MkdirAll(fmt.Sprintf("%s/%s", logPath, fileDate), os.ModePerm)
	if err != nil {
		logrus.Error(err)
		return
	}

	filename := fmt.Sprintf("%s/%s/%s.log", logPath, fileDate, appName)
	file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
	if err != nil {
		logrus.Error(err)
		return
	}
	filehook := FileDateHook{file: file, logPath: logPath, fileDate: fileDate, appName: appName}
	logrus.AddHook(&filehook)
}

func main() {
	InitFile("./log", "test")
	for {
		logrus.Errorf("test")
		time.Sleep(10 * time.Second)
		logrus.Infof("test")
	}
}
```

## 4.2 按日志等级分割

日志等级：error,warn,info,all.log

```go
package main

import (
	"fmt"
	"github.com/sirupsen/logrus"
	"os"
)

const (
	allLog  = "all"
	errLog  = "err"
	warnLog = "warn"
	infoLog = "info"
)

type FileLevelHook struct {
	file     *os.File
	errFile  *os.File
	warnFile *os.File
	infoFile *os.File
	logPath  string
}

func (hook *FileLevelHook) Levels() []logrus.Level {
	return logrus.AllLevels
}

func (hook *FileLevelHook) Fire(entry *logrus.Entry) error {
	line, _ := entry.String()
	switch entry.Level {
	case logrus.ErrorLevel:
		hook.errFile.Write([]byte(line))
	case logrus.WarnLevel:
		hook.warnFile.Write([]byte(line))
	case logrus.InfoLevel:
		hook.infoFile.Write([]byte(line))
	}
	hook.file.Write([]byte(line))
	return nil
}

func InitLevel(logPath string) {
	err := os.MkdirAll(fmt.Sprintf("%s", logPath), os.ModePerm)
	if err != nil {
		logrus.Errorf("create log path error: %v", err)
		return
	}

	allFile, err := os.OpenFile(fmt.Sprintf("%s/%s.log", logPath, allLog), os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
	errFile, err := os.OpenFile(fmt.Sprintf("%s/%s.log", logPath, errLog), os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
	warnFile, err := os.OpenFile(fmt.Sprintf("%s/%s.log", logPath, warnLog), os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
	infoFile, err := os.OpenFile(fmt.Sprintf("%s/%s.log", logPath, infoLog), os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
	fileHook := FileLevelHook{allFile, errFile, warnFile, infoFile, logPath}
	logrus.AddHook(&fileHook)
}

func main() {
	InitLevel("log_level")

	logrus.Errorf("hello")
	logrus.Errorln("error")
	logrus.Warnf("warn")
	logrus.Infof("info")
	logrus.Printf("print")

}

```

# 5.gin集成logrus

### main.go

```go
package main

import (
	"awesomeProject/gin_logrus/log"
	"awesomeProject/gin_logrus/middleware"
	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
)

func main() {
	router := gin.New()
	router.Use(middleware.LogMiddleware())
	log.InitFile("gin_logrus/logs", "server")

	router.GET("/", func(c *gin.Context) {
		logrus.Info("hello")
		c.JSON(200, gin.H{
			"message": "hello",
		})
	})

	router.Run(":8081")
}
```

### log.go

```go
package log

import (
	"fmt"
	"github.com/sirupsen/logrus"
	"os"
	"time"
)

type FileDateHook struct {
	file     *os.File
	logPath  string
	fileDate string
	appName  string
}
func (hook FileDateHook) Levels() []logrus.Level {
	return logrus.AllLevels
}

func (hook FileDateHook) Fire(entry *logrus.Entry) error {
	timer := entry.Time.Format("2006-01-02_15-04")
	line, _ := entry.String()
	if hook.fileDate == timer {
		hook.file.Write([]byte(line))
		return nil
	}
	//时间不等
	hook.file.Close()
	os.MkdirAll(fmt.Sprintf("%s/%s", hook.logPath, timer), os.ModePerm)
	filename := fmt.Sprintf("%s/%s/%s.log", hook.logPath, timer, hook.appName)

	hook.file, _ = os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
	hook.fileDate = timer
	hook.file.Write([]byte(line))
	return nil
}

func InitFile(logPath, appName string) {
	fileDate := time.Now().Format("2006-01-02_15-04")
	// 创建日志目录
	err := os.MkdirAll(fmt.Sprintf("%s/%s", logPath, fileDate), os.ModePerm)
	if err != nil {
		logrus.Error(err)
		return
	}

	filename := fmt.Sprintf("%s/%s/%s.log", logPath, fileDate, appName)
	file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
	if err != nil {
		logrus.Error(err)
		return
	}
	filehook := FileDateHook{file: file, logPath: logPath, fileDate: fileDate, appName: appName}
	logrus.AddHook(&filehook)
}
```

### log_middle.go

```go
package middleware

import (
	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
	"time"
)

func LogMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path
		raw := c.Request.URL.RawQuery
		c.Next()
		end := time.Now()
		timeSub := end.Sub(start)
		clientIP := c.ClientIP()
		method := c.Request.Method
		statusCode := c.Writer.Status()
		if raw != "" {
			path = path + "?" + raw
		}

		logrus.Infof("[GIN] %s | %d | %d | %s | %s | %s",
			start.Format("2006-01-02 15:04:05"),
			statusCode,
			timeSub,
			clientIP,
			method,
			path,
		)
	}
}
```